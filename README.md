# Поведенческие шаблоны проектирования: Команда, Стратегия, Шаблонный метод

## Определение поведенческих шаблонов проектирования

Поведенческие шаблоны проектирования отвечают за эффективное и гибкое взаимодействие между объектами. Они определяют способы коммуникации между классами и объектами, распределяя ответственность между ними, организуя алгоритмы и потоки управления. Основная цель этих шаблонов — способствовать слабой связанности и повышению гибкости программного обеспечения.

## 1. Шаблон "Команда" (Command)

### Проблема
- Необходимо отделить объект, инициирующий операцию, от объекта, который знает, как её выполнить
- Требуется поддержка отмены операций (undo)
- Нужно организовать очередь выполнения операций или их журналирование
- Необходимо параметризовать клиентов выполняемыми действиями

### Решение
Инкапсулировать запрос в виде объекта, позволяя параметризовать клиентов различными запросами, ставить запросы в очередь, логировать или отменять их.

### Через призму инкапсуляции
Шаблон "Команда" инкапсулирует действие и его параметры в отдельном объекте, что позволяет скрыть детали реализации и делает систему более модульной.

### Применение принципа "разделяй и властвуй"
Шаблон разделяет ответственность между:
- Инициатором команды (Invoker)
- Самой командой (Command)
- Получателем команды (Receiver)

### Ортогональность стратегий
Команды могут быть реализованы независимо друг от друга, а клиентский код может оперировать ими единообразно через общий интерфейс.

### Влияние многопоточности
В многопоточной среде команды могут выполняться конкурентно, что требует дополнительной синхронизации при работе с общим состоянием. Очереди команд должны быть потокобезопасными.

### Пример реализации

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <mutex>

// Receiver - получатель команды
class Light {
private:
    bool is_on = false;
    std::mutex mutex_;

public:
    void turn_on() {
        std::lock_guard<std::mutex> lock(mutex_);
        is_on = true;
        std::cout << "Свет включен" << std::endl;
    }

    void turn_off() {
        std::lock_guard<std::mutex> lock(mutex_);
        is_on = false;
        std::cout << "Свет выключен" << std::endl;
    }
};

// Command - интерфейс команды
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
};

// ConcreteCommand - конкретная команда включения света
class TurnOnCommand : public Command {
private:
    Light& light_;

public:
    explicit TurnOnCommand(Light& light) : light_(light) {}

    void execute() override {
        light_.turn_on();
    }
};

// ConcreteCommand - конкретная команда выключения света
class TurnOffCommand : public Command {
private:
    Light& light_;

public:
    explicit TurnOffCommand(Light& light) : light_(light) {}

    void execute() override {
        light_.turn_off();
    }
};

// Invoker - инициатор команды
class RemoteControl {
private:
    std::vector<std::shared_ptr<Command>> commands_;

public:
    void add_command(std::shared_ptr<Command> command) {
        commands_.push_back(command);
    }

    void execute_commands() {
        for (auto& command : commands_) {
            command->execute();
        }
    }
};

int main() {
    // Создаем получателя
    Light light;
    
    // Создаем команды
    auto turn_on = std::make_shared<TurnOnCommand>(light);
    auto turn_off = std::make_shared<TurnOffCommand>(light);
    
    // Создаем инициатора и добавляем команды
    RemoteControl remote;
    remote.add_command(turn_on);
    remote.add_command(turn_off);
    
    // Выполняем команды
    remote.execute_commands();
    
    return 0;
}
```

## 2. Шаблон "Стратегия" (Strategy)

### Проблема
- Необходимо иметь несколько вариантов алгоритма или поведения
- Требуется динамическое переключение между алгоритмами на этапе выполнения
- Нужно изолировать клиентский код от деталей реализации алгоритмов
- Хочется избежать множественных условных операторов

### Решение
Определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от клиентов, которые их используют.

### Через призму инкапсуляции
Шаблон "Стратегия" инкапсулирует различные алгоритмы в отдельных классах, что скрывает их реализацию от контекста и позволяет изменять их независимо.

### Применение принципа "разделяй и властвуй"
Шаблон разделяет ответственность между:
- Контекстом (Context), который использует алгоритм
- Стратегиями (Strategy), которые реализуют различные алгоритмы

### Ортогональность стратегий
Каждая стратегия является независимой от других и может развиваться отдельно. Контекст не зависит от конкретной реализации стратегии.

### Влияние многопоточности
В многопоточной среде важно обеспечить потокобезопасный доступ к контексту и процессу смены стратегии. Стратегии должны быть либо без состояния, либо потокобезопасными.

### Пример реализации

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <mutex>

// Strategy - интерфейс стратегии
class SortStrategy {
public:
    virtual ~SortStrategy() = default;
    virtual void sort(int arr[], int size) = 0;
};

// ConcreteStrategy - конкретная стратегия
class BubbleSort : public SortStrategy {
public:
    void sort(int arr[], int size) override {
        std::cout << "Применяется сортировка пузырьком" << std::endl;
        for (int i = 0; i < size - 1; i++) {
            for (int j = 0; j < size - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    std::swap(arr[j], arr[j + 1]);
                }
            }
        }
    }
};

// ConcreteStrategy - конкретная стратегия
class QuickSort : public SortStrategy {
private:
    int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1);
        
        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[high]);
        return (i + 1);
    }
    
    void quickSort(int arr[], int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

public:
    void sort(int arr[], int size) override {
        std::cout << "Применяется быстрая сортировка" << std::endl;
        quickSort(arr, 0, size - 1);
    }
};

// Context - контекст, использующий стратегию
class Sorter {
private:
    std::shared_ptr<SortStrategy> strategy_;
    std::mutex mutex_; // для потокобезопасной смены стратегии

public:
    explicit Sorter(std::shared_ptr<SortStrategy> strategy) : strategy_(strategy) {}
    
    void set_strategy(std::shared_ptr<SortStrategy> strategy) {
        std::lock_guard<std::mutex> lock(mutex_);
        strategy_ = strategy;
    }
    
    void performSort(int arr[], int size) {
        std::lock_guard<std::mutex> lock(mutex_);
        strategy_->sort(arr, size);
    }
};

int main() {
    int data[] = {8, 5, 2, 9, 1, 6};
    int size = sizeof(data) / sizeof(data[0]);
    
    auto bubble_strategy = std::make_shared<BubbleSort>();
    auto quick_strategy = std::make_shared<QuickSort>();
    
    Sorter sorter(bubble_strategy);
    sorter.performSort(data, size);
    
    // Вывод результата
    std::cout << "Отсортированный массив: ";
    for (int i = 0; i < size; i++) {
        std::cout << data[i] << " ";
    }
    std::cout << std::endl;
    
    // Меняем стратегию
    int data2[] = {8, 5, 2, 9, 1, 6};
    sorter.set_strategy(quick_strategy);
    sorter.performSort(data2, size);
    
    // Вывод результата
    std::cout << "Отсортированный массив: ";
    for (int i = 0; i < size; i++) {
        std::cout << data2[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 3. Шаблон "Шаблонный метод" (Template Method)

### Проблема
- Необходимо определить скелет алгоритма, позволяя подклассам переопределять определенные шаги
- Повторяющийся код в различных классах
- Нужно локализовать общее поведение в одном месте
- Требуется контролировать расширения, предоставляемые подклассами

### Решение
Определить скелет алгоритма в базовом классе, откладывая определение некоторых шагов на подклассы. Шаблонный метод позволяет подклассам переопределять части алгоритма без изменения его структуры.

### Через призму инкапсуляции
Шаблон "Шаблонный метод" инкапсулирует общую структуру алгоритма в базовом классе, позволяя подклассам реализовывать только специфичные для них части.

### Применение принципа "разделяй и властвуй"
Шаблон разделяет алгоритм на:
- Инвариантные части (остаются в базовом классе)
- Вариативные части (переопределяются в подклассах)

### Ортогональность стратегий
Базовый алгоритм и специфические реализации шагов развиваются независимо. Базовый класс устанавливает структуру, а подклассы обеспечивают вариативность без изменения общего алгоритма.

### Влияние многопоточности
При использовании в многопоточной среде нужно обеспечить потокобезопасность данных, используемых в шаблонном методе. Особое внимание требуется, если шаги алгоритма используют разделяемое состояние.

### Пример реализации

```cpp
#include <iostream>
#include <mutex>
#include <string>

// AbstractClass - абстрактный класс с шаблонным методом
class DocumentProcessor {
private:
    std::mutex mutex_; // для синхронизации в многопоточной среде

protected:
    // Примитивные операции, которые могут быть переопределены подклассами
    virtual void openDocument(const std::string& path) = 0;
    virtual void processContent() = 0;
    virtual void saveDocument(const std::string& path) = 0;
    
    // Хук: может быть переопределен, но имеет реализацию по умолчанию
    virtual bool validateDocument() {
        return true;
    }

public:
    virtual ~DocumentProcessor() = default;
    
    // Шаблонный метод, определяющий скелет алгоритма
    void processDocument(const std::string& source, const std::string& destination) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        std::cout << "Начало обработки документа..." << std::endl;
        
        openDocument(source);
        
        if (validateDocument()) {
            processContent();
            saveDocument(destination);
            std::cout << "Документ успешно обработан и сохранен." << std::endl;
        } else {
            std::cout << "Документ не прошел валидацию." << std::endl;
        }
    }
};

// ConcreteClass - конкретная реализация
class PDFProcessor : public DocumentProcessor {
protected:
    void openDocument(const std::string& path) override {
        std::cout << "Открытие PDF-документа: " << path << std::endl;
    }
    
    void processContent() override {
        std::cout << "Обработка содержимого PDF-документа..." << std::endl;
    }
    
    void saveDocument(const std::string& path) override {
        std::cout << "Сохранение PDF-документа: " << path << std::endl;
    }
    
    bool validateDocument() override {
        std::cout << "Проверка PDF-документа..." << std::endl;
        return true;
    }
};

// ConcreteClass - еще одна конкретная реализация
class WordProcessor : public DocumentProcessor {
protected:
    void openDocument(const std::string& path) override {
        std::cout << "Открытие Word-документа: " << path << std::endl;
    }
    
    void processContent() override {
        std::cout << "Обработка содержимого Word-документа..." << std::endl;
    }
    
    void saveDocument(const std::string& path) override {
        std::cout << "Сохранение Word-документа: " << path << std::endl;
    }
};

int main() {
    PDFProcessor pdfProcessor;
    pdfProcessor.processDocument("input.pdf", "output.pdf");
    
    std::cout << "\n---------------\n" << std::endl;
    
    WordProcessor wordProcessor;
    wordProcessor.processDocument("input.docx", "output.docx");
    
    return 0;
}
```

## Архитектура программного обеспечения

### Определение

Архитектура программного обеспечения — это высокоуровневая структура программной системы, которая определяет её компоненты, их взаимосвязи, контексты и принципы, управляющие её проектированием и эволюцией. Архитектура ПО представляет собой набор технических решений, которые отвечают на вопрос "как система будет реализована", и удовлетворяют функциональным и нефункциональным требованиям.

### Ключевые аспекты архитектуры ПО

1. **Структурные элементы**:
   - Компоненты и модули
   - Подсистемы
   - Слои и уровни абстракции
   - Интерфейсы взаимодействия

2. **Архитектурные решения**:
   - Стили архитектуры (монолитная, микросервисная, многоуровневая и т.д.)
   - Архитектурные паттерны (MVC, MVVM, Clean Architecture и т.д.)
   - Стратегии интеграции компонентов

3. **Качественные атрибуты**:
   - Производительность
   - Масштабируемость
   - Надежность
   - Безопасность
   - Поддерживаемость

## Влияние многопоточности на архитектуру ПО

Многопоточное выполнение существенно влияет на архитектуру программного обеспечения, накладывая дополнительные требования и ограничения на проектирование системы:

### 1. Проектирование потокобезопасных компонентов

В многопоточной среде компоненты должны быть спроектированы с учетом конкурентного доступа. Это приводит к следующим архитектурным решениям:

- **Иммутабельные объекты**: Предпочтение неизменяемых структур данных, которые безопасны для параллельного использования
- **Инкапсуляция доступа к состоянию**: Строгий контроль доступа к разделяемым ресурсам через синхронизационные примитивы
- **Минимизация состояния**: Уменьшение объема разделяемого состояния между потоками

### 2. Влияние на декомпозицию системы

Многопоточность влияет на то, как система разбивается на компоненты:

- **Параллельная декомпозиция**: Разделение системы на компоненты с учетом возможности их параллельного выполнения
- **Асинхронные границы**: Определение границ компонентов с учетом асинхронного взаимодействия
- **Изоляция потоков**: Разделение системы на домены с минимальным взаимодействием между потоками

### 3. Изменение коммуникационных шаблонов

Многопоточность меняет способы взаимодействия компонентов:

- **Асинхронные коммуникации**: Замена синхронных вызовов на асинхронные сообщения
- **Очереди сообщений**: Использование очередей для буферизации коммуникаций между потоками
- **Акторная модель**: Реализация компонентов как акторов, обменивающихся сообщениями

### 4. Дополнительные архитектурные слои и компоненты

Многопоточность требует введения дополнительных архитектурных элементов:

- **Планировщики задач**: Компоненты для управления распределением задач между потоками
- **Пулы потоков**: Инфраструктура для эффективного использования потоков
- **Мониторинг и профилирование**: Системы для отслеживания производительности в многопоточной среде

### 5. Влияние на архитектурные паттерны

Традиционные архитектурные паттерны требуют адаптации для многопоточной среды:

- **Многопоточный MVC**: Необходимость синхронизации между моделью, представлением и контроллером
- **Реактивная архитектура**: Предпочтение реактивных паттернов для асинхронной обработки
- **Функциональные подходы**: Переход к более функциональному стилю программирования для избежания проблем с состоянием

### 6. Влияние на нефункциональные требования

Многопоточность влияет на качественные характеристики системы:

- **Производительность**: Потенциальное увеличение пропускной способности, но с риском накладных расходов на синхронизацию
- **Масштабируемость**: Улучшение горизонтальной масштабируемости
- **Сложность тестирования**: Повышение сложности проверки корректности работы системы
- **Отладка и диагностика**: Усложнение процессов отладки и поиска проблем

В целом, многопоточность требует более строгого подхода к архитектуре ПО, с более четким определением границ компонентов, детальным проектированием потокобезопасного взаимодействия и тщательным анализом потенциальных проблем конкурентного выполнения.
